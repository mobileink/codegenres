10				Annotated syntax ISO/IEC 13568:2002(E)


10 Annotated syntax

10.1 Introduction

The annotated syntax defines a language that includes all sentences that could be produced by application of the
syntactic transformation rules (clause 12) to sentences of the concrete syntax (clause 8). This language's set of
sentences would be a subset of that defined by the concrete syntax but for introduction of type annotations and
use of expressions in place of schema texts.
Like the concrete syntax, this annotated syntax is written in terms of the tokens generated by the lexis; there
are no terminal symbols within this syntax. The added type annotation notation uses three tokens not defined
in the lexis: GIVEN, GENTYPE, and oo
.
Some additional characters that are presumed to be distinct from the characters used in concrete phrases are
introduced as follows. The constituent words of operators are glued together to form single names using the
character 1, which belongs to the WORDGLUE character class. (These single names cannot clash with any existing
names.) For comparing the bindings of two schemas, one schema is decorated using the character ./, which
belongs to the STROKECHAR character class. (Inclusion of a schema so decorated cannot capture any existing
references.) For defining the semantics of types, the names of given sets and generic parameters are decorated
with characters ~ and  respectively, both of which belong to the STROKECHAR character class. (This avoids local
declarations of the same names making holes in the scopes of the types.)
There are no parentheses in the annotated syntax as defined here. A sentence or phrase of the annotated
syntax should be thought of as a tree structure of nested formulae. When presented as linear text, however, the
precedences of the concrete syntax may be assumed and parentheses may be inserted to override those precedences.
The precedence of the type annotation oo
operator is then weaker than all other operators, and the precedences
and associativities of the type notations are analogous to those of the concrete notations of similar appearance.
NOTE 1 This annotated syntax permits some verification of the syntactic transformation rules to be performed.
NOTE 2 The annotated syntax is similar to an annotated tree (abstract syntax) used in a tool, but the level of
abstraction eected by the characterization rules and syntactic transformation rules might not be appropriate for a
tool.
10.2 Formal definition of annotated syntax
Specification = { Section } ; (* sectioned specification *)
Section = ZED , section , NAME , parents , [ NAME , { ;-tok , NAME } ] , END ,
{ Paragraph } , [ oo
, SectTypeEnv ] ; (* inheriting section *)
Paragraph = ZED , [-tok , NAME , { ;-tok , NAME } , ]-tok , END ,
[ oo
, Signature ] (* given types *)
| AX , Expression , END ,
[ oo
, Signature ] (* axiomatic description *)
| GENAX , [-tok , NAME , { ;-tok , NAME } , ]-tok , Expression , END ,
[ oo
, Signature ] (* generic axiomatic description *)
| ZED , NAME , ::= , NAME , [ hh , Expression , ii ] ,
{ j-tok , NAME , [ hh , Expression , ii ] } ,
{ & , NAME , ::= , NAME , [ hh , Expression , ii ] ,
{ j-tok , NAME , [ hh , Expression , ii ] } } , END ,
[ oo
, Signature ] (* free types *)
| ZED , `? , Predicate , END ,
[ oo
, Signature ] (* conjecture *)
| ZED , [-tok , NAME , { ;-tok , NAME } , ]-tok , `? , Predicate , END ,
[ oo
, Signature ] (* generic conjecture *)
;
c ISO/IEC 2002|All rights reserved		41



ISO/IEC 13568:2002(E) 10 Annotated syntax
Predicate = Expression , 2 , Expression (* membership *)
| true (* truth *)
| : , Predicate (* negation *)
| Predicate , ^ , Predicate (* conjunction *)
| 8 , Expression ,  , Predicate (* universal quantification *)
| 9
1 , Expression ,  , Predicate (* unique existential quantification *)
;
Expression = NAME ,
[ oo
, Type ] (* reference *)
| NAME , [-tok , Expression , { ;-tok , Expression } , ]-tok ,
[ oo
, Type ] (* generic instantiation *)
| f-tok , [ Expression , { ;-tok , Expression } ] , g-tok ,
[ oo
, Type ] (* set extension *)
| f-tok , Expression ,  , Expression , g-tok ,
[ oo
, Type ] (* set comprehension *)
| P , Expression ,
[ oo
, Type ] (* powerset *)
| (-tok , Expression , ;-tok , Expression , { ;-tok , Expression } , )-tok ,
[ oo
, Type ] (* tuple extension *)
| Expression , : , NUMERAL ,
[ oo
, Type ] (* tuple selection *)
| hj , NAME , == , Expression ,
{ ;-tok , NAME , == , Expression } , ji ,
[ oo
, Type ] (* binding extension *)
|  , Expression , { STROKE } ,
[ oo
, Type ] (* binding construction *)
| Expression , : , NAME ,
[ oo
, Type ] (* binding selection *)
| Expression , Expression ,
[ oo
, Type ] (* application *)
|  , Expression ,  , Expression ,
[ oo
, Type ] (* definite description *)
| [-tok , NAME , : , Expression , ]-tok ,
[ oo
, Type ] (* variable construction *)
| [-tok , Expression , j-tok , Predicate , ]-tok ,
[ oo
, Type ] (* schema construction *)
| : , Expression ,
[ oo
, Type ] (* schema negation *)
| Expression , ^ , Expression ,
[ oo
, Type ] (* schema conjunction *)
| Expression , n , (-tok , NAME , { ;-tok , NAME } , )-tok ,
[ oo
, Type ] (* schema hiding *)
| 8 , Expression ,  , Expression ,
[ oo, Type ] (* schema universal quantification *)
| 9
1 , Expression ,  , Expression ,
[ oo
, Type ] (* schema unique existential quantification *)
| Expression , [-tok , NAME , = , NAME ,
{ ;-tok , NAME , = , NAME } , ]-tok ,
[ oo
, Type ] (* schema renaming *)
| pre , Expression ,
[ oo
, Type ] (* schema precondition *)
42					c ISO/IEC 2002|All rights reserved



11 Prelude ISO/IEC 13568:2002(E)
| Expression , o9
, Expression ,
[ oo
, Type ] (* schema composition *)
| Expression , >> , Expression ,
[ oo
, Type ] (* schema piping *)
| Expression , STROKE ,
[ oo
, Type ] (* schema decoration *)
;
SectTypeEnv = [ NAME , : , (-tok , NAME , ;-tok , Type , )-tok ,
{ ; -tok , NAME , : , (-tok , NAME , ;-tok , Type , )-tok } ] ;
Type = [-tok , NAME , { ;-tok , NAME } , ]-tok ,
Type2 , [ ;-tok , Type2 ] (* generic type *)
| Type2
;
Type2 = GIVEN , NAME (* given type *)
| GENTYPE , NAME (* generic parameter type *)
| P , Type2 (* powerset type *)
| Type2 ,  , Type2 , {  , Type2 } (* Cartesian product type *)
| [-tok , Signature , ]-tok (* schema type *)
;
Signature = [ NAME , : , Type , { ; -tok , NAME , : , Type } ]
|  (* empty signature *)
;
10.3 Notes
NOTE 1 More free types than necessary are permitted by this syntax: as a result of the syntactic transformation
in 12.2.3.5, all elements appear before all injections.
NOTE 2 The only signatures that contain generic types are those in the annotations of generic axiomatic description
paragraphs.
